package com.logotec.ir;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * Emite texto LLVM IR (.ll) a partir del IR intermedio del proyecto.
 *
 * Notas:
 * - Genera una función `main` que contiene un bloque por instrucción IR
 *   y traduce saltos condicionales a `br`/`fcmp` en LLVM.
 * - Declara las funciones externas del runtime (los nombres deben coincidir
 *   con las definiciones en `native/logo_runtime.cpp` / .h).
 * - Crea variables globales para las variables del programa y constantes
 *   para los nombres (strings) usadas por las llamadas al runtime que requieren
 *   un `i8*`.
 *
 * Esta clase produce LLVM IR legible y apto para pasar por `opt`/`llc`.
 */
public class IRToLLVMEmitter {

    public void emit(IRProgram program, Path outFile) throws IOException {
        List<IRInstr> instrs = program.getInstrs();

    // First pass: collect temps, vars and label positions
        Set<String> temps = new TreeSet<>();
        Set<String> vars = new TreeSet<>();
        Map<String, Integer> labelPos = new HashMap<>();

        for (int i = 0; i < instrs.size(); ++i) {
            IRInstr instr = instrs.get(i);
            String s = instr.toString();
            // parse op and operands
            int sp = s.indexOf(' ');
            String op = sp > 0 ? s.substring(0, sp) : s;
            String inside = sp > 0 ? s.substring(sp + 1).trim() : "[]";
            String[] parts = parseInside(inside);
            if ("LABEL".equals(op) && parts.length > 0) {
                labelPos.put(stripQuotes(parts[0]), i);
            }
            for (String p : parts) {
                p = p.trim();
                if (p.startsWith("t")) temps.add(p);
                else if (isNumber(p)) {
                    // constant
                } else {
                    // could be variable or label string; if it's used as operand (not as LABEL arg)
                    // assume variables
                    if (!p.isEmpty() && !p.startsWith("\"")) vars.add(p);
                }
            }
        }

        StringBuilder sb = new StringBuilder();

        // Detect procedure ranges: LABEL ... ENDPROC pairs
        Map<String, int[]> procs = new LinkedHashMap<>();
        Set<Integer> procInstrIdxs = new HashSet<>();
        for (int i = 0; i < instrs.size(); ++i) {
            IRInstr instr = instrs.get(i);
            String s = instr.toString();
            int sp = s.indexOf(' ');
            String op = sp > 0 ? s.substring(0, sp) : s;
            String inside = sp > 0 ? s.substring(sp + 1).trim() : "[]";
            String[] parts = parseInside(inside);
            if ("LABEL".equals(op) && parts.length > 0) {
                String lbl = stripQuotes(parts[0]);
                // find matching ENDPROC
                for (int j = i+1; j < instrs.size(); ++j) {
                    IRInstr i2 = instrs.get(j);
                    String s2 = i2.toString();
                    int sp2 = s2.indexOf(' ');
                    String op2 = sp2 > 0 ? s2.substring(0, sp2) : s2;
                    String inside2 = sp2 > 0 ? s2.substring(sp2 + 1).trim() : "[]";
                    String[] parts2 = parseInside(inside2);
                    if ("ENDPROC".equals(op2) && parts2.length>0 && stripQuotes(parts2[0]).equals(lbl)) {
                        procs.put(lbl, new int[] { i+1, j-1 });
                        for (int k=i; k<=j; ++k) procInstrIdxs.add(k);
                        break;
                    }
                }
            }
        }

        // Module header: declare external runtime functions used
        sb.append("; Module generated by IRToLLVMEmitter\n\n");
        sb.append("declare void @logo_reset()\n");
        sb.append("declare void @logo_avanza(double)\n");
        sb.append("declare void @logo_retrocede(double)\n");
        sb.append("declare void @logo_giraderecha(double)\n");
        sb.append("declare void @logo_giraizquierda(double)\n");
        sb.append("declare void @logo_ponpos(double,double)\n");
        sb.append("declare void @logo_ponxy(double,double)\n");
        sb.append("declare void @logo_ponrumbo(double)\n");
        sb.append("declare void @logo_ponx(double)\n");
        sb.append("declare void @logo_pony(double)\n");
        sb.append("declare void @logo_centro()\n");
        sb.append("declare void @logo_inic(i8*, double)\n");
        sb.append("declare void @logo_haz(i8*, double)\n");
        sb.append("declare void @logo_inc(double, double)\n");
        sb.append("declare double @logo_suma(double,double)\n");
        sb.append("declare double @logo_diferencia(double,double)\n");
        sb.append("declare double @logo_producto(double,double)\n");
        sb.append("declare double @logo_division(double,double)\n");
        sb.append("declare double @logo_potencia(double,double)\n");
        sb.append("declare double @logo_azar(double)\n");
        sb.append("declare i32 @logo_iguales(double,double)\n");
        sb.append("declare i32 @logo_mayorque(double,double)\n");
        sb.append("declare i32 @logo_menorque(double,double)\n\n");

        // Globals for variable name strings and for variable storage
        int strId = 0;
        Map<String, String> varNameGlobal = new HashMap<>();
        for (String v : vars) {
            String gstr = ".str." + sanitize(v) ;
            varNameGlobal.put(v, gstr);
            byte[] bytes = (v + "\\00").getBytes();
            sb.append(String.format("@%s = private constant [%d x i8] c\"%s\\00\"\n", gstr, bytes.length, escapeCString(v)));
        }
        sb.append("\n");

        // Globals for variable storage
        for (String v : vars) {
            sb.append(String.format("@var_%s = global double 0.0\n", sanitize(v)));
        }
        sb.append("\n");

        // Allocate temps as globals as well (simpler than alloca/phi across blocks)
        for (String t : temps) {
            sb.append(String.format("@temp_%s = global double 0.0\n", t));
        }
        sb.append("\n");

    // (procedures and main emitted below)
        // Emit procedure functions first
        for (Map.Entry<String,int[]> e : procs.entrySet()) {
            String pname = e.getKey();
            int start = e.getValue()[0];
            int end = e.getValue()[1];
            sb.append(String.format("define void @%s() {\n", sanitize(pname)));
            sb.append("entry:\n");
            // track assigned vars inside proc to decide inic/haz
            Set<String> assigned = new HashSet<>();
            for (int k = start; k <= end; ++k) {
                IRInstr instr = instrs.get(k);
                String s = instr.toString();
                int sp = s.indexOf(' ');
                String op = sp > 0 ? s.substring(0, sp) : s;
                String inside = sp > 0 ? s.substring(sp + 1).trim() : "[]";
                String[] parts = parseInside(inside);
                // linear emission (no bb labels)
                if ("STORE".equals(op) && parts.length>=2) {
                    String dest = parts[0].trim();
                    String src = parts[1].trim();
                    String val = loadValueLLVM(src, sb);
                    if (dest.startsWith("t")) {
                        sb.append(String.format("  store double %s, double* @temp_%s\n", val, dest));
                    } else {
                        String vname = sanitize(dest);
                        sb.append(String.format("  store double %s, double* @var_%s\n", val, vname));
                        String gstr = varNameGlobal.get(dest);
                        if (gstr != null) {
                            sb.append(String.format("  %%ptr%d = getelementptr inbounds ([%d x i8], [%d x i8]* @%s, i32 0, i32 0\n", strId, dest.length()+1, dest.length()+1, gstr));
                            sb.append(String.format("  %%cast%d = bitcast i8* %%ptr%d to i8*\n", strId, strId));
                            if (!assigned.contains(dest)) {
                                sb.append(String.format("  call void @logo_inic(i8* %%cast%d, double %s)\n", strId, val));
                            } else {
                                sb.append(String.format("  call void @logo_haz(i8* %%cast%d, double %s)\n", strId, val));
                            }
                            strId++;
                        }
                        assigned.add(dest);
                    }
                } else if ("AVANZA".equals(op) && parts.length>=1) {
                    String v = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_avanza(double %s)\n", v));
                } else if ("RETROCEDE".equals(op) && parts.length>=1) {
                    String v = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_retrocede(double %s)\n", v));
                } else if ("GIRADERECHA".equals(op) && parts.length>=1) {
                    String v = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_giraderecha(double %s)\n", v));
                } else if ("GIRAIZQUIERDA".equals(op) && parts.length>=1) {
                    String v = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_giraizquierda(double %s)\n", v));
                } else if ("PONPOS".equals(op) && parts.length>=2) {
                    String a = loadValueLLVM(parts[0].trim(), sb);
                    String b = loadValueLLVM(parts[1].trim(), sb);
                    sb.append(String.format("  call void @logo_ponpos(double %s, double %s)\n", a, b));
                } else if ("PONXY".equals(op) && parts.length>=2) {
                    String a = loadValueLLVM(parts[0].trim(), sb);
                    String b = loadValueLLVM(parts[1].trim(), sb);
                    sb.append(String.format("  call void @logo_ponxy(double %s, double %s)\n", a, b));
                } else if ("PONRUMBO".equals(op) && parts.length>=1) {
                    String a = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_ponrumbo(double %s)\n", a));
                } else if ("PONX".equals(op) && parts.length>=1) {
                    String a = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_ponx(double %s)\n", a));
                } else if ("PONY".equals(op) && parts.length>=1) {
                    String a = loadValueLLVM(parts[0].trim(), sb);
                    sb.append(String.format("  call void @logo_pony(double %s)\n", a));
                } else if ("CENTRO".equals(op)) {
                    sb.append("  call void @logo_centro()\n");
                } else {
                    // unsupported inside proc: ignore for now
                }
            }
            sb.append("  ret void\n}\n\n");
        }

        // Emit main: call procs, then emit any top-level instructions not inside procs
        sb.append("define i32 @main() {\n");
        sb.append("entry:\n");
        sb.append("  call void @logo_reset()\n");
        // call all procs in order
        for (String pname : procs.keySet()) {
            sb.append(String.format("  call void @%s()\n", sanitize(pname)));
        }
        // emit remaining top-level instructions (linear)
        Set<String> assignedMain = new HashSet<>();
        for (int i = 0; i < instrs.size(); ++i) {
            if (procInstrIdxs.contains(i)) continue;
            IRInstr instr = instrs.get(i);
            String s = instr.toString();
            int sp = s.indexOf(' ');
            String op = sp > 0 ? s.substring(0, sp) : s;
            String inside = sp > 0 ? s.substring(sp + 1).trim() : "[]";
            String[] parts = parseInside(inside);
            if ("STORE".equals(op) && parts.length>=2) {
                String dest = parts[0].trim();
                String src = parts[1].trim();
                String val = loadValueLLVM(src, sb);
                if (dest.startsWith("t")) {
                    sb.append(String.format("  store double %s, double* @temp_%s\n", val, dest));
                } else {
                    String vname = sanitize(dest);
                    sb.append(String.format("  store double %s, double* @var_%s\n", val, vname));
                    String gstr = varNameGlobal.get(dest);
                    if (gstr != null) {
                        sb.append(String.format("  %%ptr%d = getelementptr inbounds ([%d x i8], [%d x i8]* @%s, i32 0, i32 0\n", strId, dest.length()+1, dest.length()+1, gstr));
                        sb.append(String.format("  %%cast%d = bitcast i8* %%ptr%d to i8*\n", strId, strId));
                        if (!assignedMain.contains(dest)) {
                            sb.append(String.format("  call void @logo_inic(i8* %%cast%d, double %s)\n", strId, val));
                        } else {
                            sb.append(String.format("  call void @logo_haz(i8* %%cast%d, double %s)\n", strId, val));
                        }
                        strId++;
                    }
                    assignedMain.add(dest);
                }
            } else if ("AVANZA".equals(op) && parts.length>=1) {
                String v = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_avanza(double %s)\n", v));
            } else if ("RETROCEDE".equals(op) && parts.length>=1) {
                String v = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_retrocede(double %s)\n", v));
            } else if ("GIRADERECHA".equals(op) && parts.length>=1) {
                String v = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_giraderecha(double %s)\n", v));
            } else if ("GIRAIZQUIERDA".equals(op) && parts.length>=1) {
                String v = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_giraizquierda(double %s)\n", v));
            } else if ("PONPOS".equals(op) && parts.length>=2) {
                String a = loadValueLLVM(parts[0].trim(), sb);
                String b = loadValueLLVM(parts[1].trim(), sb);
                sb.append(String.format("  call void @logo_ponpos(double %s, double %s)\n", a, b));
            } else if ("PONXY".equals(op) && parts.length>=2) {
                String a = loadValueLLVM(parts[0].trim(), sb);
                String b = loadValueLLVM(parts[1].trim(), sb);
                sb.append(String.format("  call void @logo_ponxy(double %s, double %s)\n", a, b));
            } else if ("PONRUMBO".equals(op) && parts.length>=1) {
                String a = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_ponrumbo(double %s)\n", a));
            } else if ("PONX".equals(op) && parts.length>=1) {
                String a = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_ponx(double %s)\n", a));
            } else if ("PONY".equals(op) && parts.length>=1) {
                String a = loadValueLLVM(parts[0].trim(), sb);
                sb.append(String.format("  call void @logo_pony(double %s)\n", a));
            } else if ("CENTRO".equals(op)) {
                sb.append("  call void @logo_centro()\n");
            }
        }
        sb.append("  ret i32 0\n}\n");

        Files.writeString(outFile, sb.toString());
    }

    // helpers
    private static String[] parseInside(String inside) {
        inside = inside.trim();
        if (inside.startsWith("[") && inside.endsWith("]")) {
            String mid = inside.substring(1, inside.length() - 1).trim();
            if (mid.isEmpty()) return new String[0];
            // split on comma followed by space (as Arrays.toString does)
            return mid.split("\\, ");
        }
        return new String[0];
    }

    private static boolean isNumber(String s) {
        try { Double.parseDouble(s); return true; } catch (Exception e) { return false; }
    }

    private static String stripQuotes(String s) {
        s = s.trim();
        if (s.startsWith("\"") && s.endsWith("\"")) return s.substring(1, s.length()-1);
        return s;
    }

    private static String sanitize(String name) { return name.replaceAll("[^A-Za-z0-9_]", "_"); }

    private static String escapeCString(String s) {
        return s.replace("\\", "\\\\").replace("\"", "\\\"");
    }

    // Load a value into an LLVM literal or generate a load instruction and return the name
    // Note: This helper appends load/call instructions inline to sb when necessary and
    // returns either a literal like 42.0 or a temporary name like %r
    private String loadValueLLVM(String operand, StringBuilder sb) {
        operand = operand.trim();
        if (operand.startsWith("t")) {
            String tmp = String.format("@temp_%s", operand);
            String rname = "%v" + Math.abs(operand.hashCode()) + System.nanoTime();
            sb.append(String.format("  %s = load double, double* %s\n", rname, tmp));
            return rname;
        }
        if (isNumber(operand)) {
            // ensure double literal has a decimal
            if (!operand.contains(".")) operand = operand + ".0";
            return operand;
        }
        // variable
        String vname = sanitize(operand);
        String rname = "%v" + Math.abs(operand.hashCode()) + System.nanoTime();
        sb.append(String.format("  %s = load double, double* @var_%s\n", rname, vname));
        return rname;
    }
}
